/**
 * Static catalog fetcher: reads pre-built JSON files from Storage.
 * Zero DB queries at runtime. Data is generated by sync-catalog Edge Function.
 */

export interface CatalogItem {
  id: string;
  tmdb_id: number;
  title: string;
  poster_path: string | null;
  backdrop_path?: string | null;
  vote_average: number | null;
  release_date: string | null;
  content_type: string;
}

interface PageData {
  total: number;
  page: number;
  per_page: number;
  items: CatalogItem[];
}

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const STORAGE_BASE = `${SUPABASE_URL}/storage/v1/object/public/catalog`;
const ITEMS_PER_PAGE = 100;
const CACHE_TTL_MS = 10 * 60 * 1000; // 10 min

interface CacheEntry {
  data: PageData;
  ts: number;
}

const _cache = new Map<string, CacheEntry>();

function cacheKey(contentType: string, page: number): string {
  return `${contentType}:${page}`;
}

function getCached(key: string): CacheEntry | null {
  const entry = _cache.get(key);
  if (!entry) return null;
  if (Date.now() - entry.ts > CACHE_TTL_MS) {
    _cache.delete(key);
    return null;
  }
  return entry;
}

function setCache(key: string, data: PageData) {
  _cache.set(key, { data, ts: Date.now() });
  // Evict old entries if cache grows too large
  if (_cache.size > 200) {
    const oldest = [..._cache.entries()].sort((a, b) => a[1].ts - b[1].ts);
    for (let i = 0; i < 50; i++) _cache.delete(oldest[i][0]);
  }
}

async function fetchPage(contentType: string, page: number): Promise<PageData> {
  const key = cacheKey(contentType, page);
  const cached = getCached(key);
  if (cached) return cached.data;

  const url = `${STORAGE_BASE}/${contentType}/${page}.json`;
  try {
    const res = await fetch(url);
    if (!res.ok) {
      // File doesn't exist yet â€” return empty
      return { total: 0, page, per_page: ITEMS_PER_PAGE, items: [] };
    }
    const data: PageData = await res.json();
    setCache(key, data);
    return data;
  } catch {
    return { total: 0, page, per_page: ITEMS_PER_PAGE, items: [] };
  }
}

export async function fetchCatalog(
  contentType: string,
  opts?: { limit?: number; offset?: number }
): Promise<{ items: CatalogItem[]; total: number }> {
  const limit = opts?.limit ?? 100;
  const offset = opts?.offset ?? 0;

  // Calculate which storage pages we need
  const startPage = Math.floor(offset / ITEMS_PER_PAGE) + 1;
  const endPage = Math.floor((offset + limit - 1) / ITEMS_PER_PAGE) + 1;

  const pages: PageData[] = [];
  const fetches = [];
  for (let p = startPage; p <= endPage; p++) {
    fetches.push(fetchPage(contentType, p));
  }
  const results = await Promise.all(fetches);
  pages.push(...results);

  if (pages.length === 0 || pages[0].total === 0) {
    return { items: [], total: 0 };
  }

  // Merge items from all fetched pages
  const allItems: CatalogItem[] = [];
  for (const page of pages) {
    allItems.push(...page.items);
  }

  // Slice to respect offset within the first page and limit
  const startInFirstPage = offset % ITEMS_PER_PAGE;
  const sliced = allItems.slice(startInFirstPage, startInFirstPage + limit);

  return { items: sliced, total: pages[0].total };
}

export async function fetchCatalogRow(contentType: string, limit = 20): Promise<CatalogItem[]> {
  const { items } = await fetchCatalog(contentType, { limit, offset: 0 });
  return items;
}
