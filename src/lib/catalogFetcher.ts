/**
 * Static catalog fetcher: reads pre-built JSON files from Storage.
 * Zero DB queries. Data is generated by generate-catalog Edge Function.
 * Aggressive in-memory caching to avoid re-downloads.
 */

export interface CatalogItem {
  id: string;
  tmdb_id: number;
  title: string;
  poster_path: string | null;
  backdrop_path?: string | null;
  vote_average: number | null;
  release_date: string | null;
  content_type: string;
}

interface PageData {
  total: number;
  page: number;
  per_page: number;
  items: CatalogItem[];
}

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const STORAGE_BASE = `${SUPABASE_URL}/storage/v1/object/public/catalog`;
const ITEMS_PER_PAGE = 100;

// Aggressive cache: 30 min TTL, survives navigation
const CACHE_TTL_MS = 30 * 60 * 1000;

interface CacheEntry {
  data: PageData;
  ts: number;
}

const _cache = new Map<string, CacheEntry>();

function cacheKey(contentType: string, page: number): string {
  return `${contentType}:${page}`;
}

function getCached(key: string): CacheEntry | null {
  const entry = _cache.get(key);
  if (!entry) return null;
  if (Date.now() - entry.ts > CACHE_TTL_MS) {
    _cache.delete(key);
    return null;
  }
  return entry;
}

function setCache(key: string, data: PageData) {
  _cache.set(key, { data, ts: Date.now() });
  if (_cache.size > 200) {
    const oldest = [..._cache.entries()].sort((a, b) => a[1].ts - b[1].ts);
    for (let i = 0; i < 50; i++) _cache.delete(oldest[i][0]);
  }
}

async function fetchPage(contentType: string, page: number): Promise<PageData> {
  const key = cacheKey(contentType, page);
  const cached = getCached(key);
  if (cached) return cached.data;

  const url = `${STORAGE_BASE}/${contentType}/${page}.json`;
  try {
    const res = await fetch(url, {
      // Browser will respect cache-control headers from Storage
      cache: "default",
    });
    if (!res.ok) {
      return { total: 0, page, per_page: ITEMS_PER_PAGE, items: [] };
    }
    const data: PageData = await res.json();
    setCache(key, data);
    return data;
  } catch {
    return { total: 0, page, per_page: ITEMS_PER_PAGE, items: [] };
  }
}

export async function fetchCatalog(
  contentType: string,
  opts?: { limit?: number; offset?: number }
): Promise<{ items: CatalogItem[]; total: number }> {
  const limit = opts?.limit ?? 100;
  const offset = opts?.offset ?? 0;

  const startPage = Math.floor(offset / ITEMS_PER_PAGE) + 1;
  const endPage = Math.floor((offset + limit - 1) / ITEMS_PER_PAGE) + 1;

  const fetches = [];
  for (let p = startPage; p <= endPage; p++) {
    fetches.push(fetchPage(contentType, p));
  }
  const pages = await Promise.all(fetches);

  if (pages.length === 0 || pages[0].total === 0) {
    return { items: [], total: 0 };
  }

  const allItems: CatalogItem[] = [];
  for (const page of pages) {
    allItems.push(...page.items);
  }

  const startInFirstPage = offset % ITEMS_PER_PAGE;
  const sliced = allItems.slice(startInFirstPage, startInFirstPage + limit);

  return { items: sliced, total: pages[0].total };
}

export async function fetchCatalogRow(contentType: string, limit = 20): Promise<CatalogItem[]> {
  const { items } = await fetchCatalog(contentType, { limit, offset: 0 });
  return items;
}

/** Fetch manifest stats (lightweight, cached) */
let _manifestCache: { data: any; ts: number } | null = null;

export function invalidateCatalogCache() {
  _manifestCache = null;
  _m3uIdsCache = null;
  _cache.clear();
}

export async function fetchCatalogManifest(): Promise<any> {
  if (_manifestCache && Date.now() - _manifestCache.ts < CACHE_TTL_MS) {
    return _manifestCache.data;
  }
  try {
    const res = await fetch(`${STORAGE_BASE}/manifest.json`, { cache: "no-store" });
    if (!res.ok) return null;
    const data = await res.json();
    _manifestCache = { data, ts: Date.now() };
    return data;
  } catch {
    return null;
  }
}

/** Fetch M3U ID set for cross-reference */
let _m3uIdsCache: { data: any; ts: number } | null = null;

export async function fetchM3UIDs(): Promise<{ movies: number[]; series: number[] } | null> {
  if (_m3uIdsCache && Date.now() - _m3uIdsCache.ts < CACHE_TTL_MS) {
    return _m3uIdsCache.data;
  }
  try {
    const res = await fetch(`${STORAGE_BASE}/m3u-index/ids.json`, { cache: "default" });
    if (!res.ok) return null;
    const data = await res.json();
    _m3uIdsCache = { data, ts: Date.now() };
    return data;
  } catch {
    return null;
  }
}

/** Compute precise video coverage by cross-referencing catalog with M3U IDs */
export async function computeVideoCoverage(manifest: any): Promise<{
  moviesWithVideo: number; seriesWithVideo: number; totalWithVideo: number;
  moviesWithout: number; seriesWithout: number; totalWithout: number;
  catalogMovies: number; catalogSeries: number;
} | null> {
  const ids = await fetchM3UIDs();
  if (!ids) return null;

  const m3uSet = new Set([...(ids.movies || []), ...(ids.series || [])]);
  const catalogMovies = manifest?.types?.movie?.total || 0;
  const catalogSeries = manifest?.types?.series?.total || 0;
  const moviePages = manifest?.types?.movie?.pages || 0;
  const seriesPages = manifest?.types?.series?.pages || 0;

  let moviesWithVideo = 0;
  let seriesWithVideo = 0;

  // Check movies (load all pages in parallel batches of 10)
  const checkPages = async (type: string, pages: number) => {
    let count = 0;
    for (let start = 1; start <= pages; start += 10) {
      const batch = [];
      for (let p = start; p <= Math.min(start + 9, pages); p++) {
        batch.push(fetchPage(type, p));
      }
      const results = await Promise.all(batch);
      for (const page of results) {
        for (const item of page.items) {
          if (m3uSet.has(item.tmdb_id)) count++;
        }
      }
    }
    return count;
  };

  [moviesWithVideo, seriesWithVideo] = await Promise.all([
    checkPages("movie", moviePages),
    checkPages("series", seriesPages),
  ]);

  return {
    moviesWithVideo, seriesWithVideo,
    totalWithVideo: moviesWithVideo + seriesWithVideo,
    moviesWithout: catalogMovies - moviesWithVideo,
    seriesWithout: catalogSeries - seriesWithVideo,
    totalWithout: (catalogMovies - moviesWithVideo) + (catalogSeries - seriesWithVideo),
    catalogMovies, catalogSeries,
  };
}
